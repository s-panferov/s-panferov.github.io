---
layout: post
title:  "Promise и Deferred. Часть 2. Библиотека Q."
date:   2013-11-22 22:00
languages: JavaScript
categories:
---

Сегодня в нашем обзоре рассмотрим библиотеку промисов Q. Данная библиотека предоставляет каноническую (на мой взгляд) и самую полную реализацию промисов. 

Дальше я во многом буду повторять официальную документацию к библиотеке, но постараюсь попутно объяснять вещи более понятным языком, чем это делает ман.

<!--more-->

Промисы имеют метод `then`, который вы можете использовать для того, чтобы получить вычисленное значение или ошибку. Если вычисление значение пройдет успешно, то будет вызвана первая переданная в метод `then` функция. Если же в процессе вычисления будет выброшено исключение, то будет вызвана функция, которую можно передать вторым аргументом.

~~~js
promiseMeSomething().then(
	function (value) {
	}, 
	function (reason) {
	}
);
~~~

Важно учесть, что разрешение (resolution) промиса всегда выполняется асинхронно в следующем тике. Это гарантирует вам, что `then` вернет управление в ваш код до вызова любого из переданных обработчиков.

Дальше мы рассмотрим различные особенности промисов, которые предоставляет нам библиотека Q.

## Всплытие (Propagation)

Вы можете запомнить результат выполнения метода `then`. Библиотека устроена таким образом, что результатом выполнения метода `then` будет новый промис с любопытными свойствами:

~~~js
var outputPromise = getInputPromise().then(
	function (input) {
		// function success
	}, 
	function (reason) {
		// function error
	}
);
~~~

`outputPromise` становится промисом для результата выполнения одного из обработчиков `getInputPromise`. Так как выполниться может только один из них (функция либо вернет значение, либо выбросит исключение), то только одна функция будет источником результата для `outputPromise`. Назовем сработавшую функцию (success или error) "хендлером" и посмотрим на правила, которыми руководствуется библиотека Q для разрешения `outputPromise`

* Если хендлер успешно вернул значение, то `outputPromise` будет разрешен (далее "зарезолвлен", от слова "resolve") с этим значением и вызовом первого, "успешного" обработчика.
* Если хендлер выбросил исключение, то `outputPromise` будет разрешен с вызовом второго обработчика (далее "зареджекчен", от слова "reject"), обработчика ошибки.
* Существует еще одна любопытная возможность. Если хендлер вернет промис, то `outputPromise` "превратится" в него. Эта особенность сложна для понимания, но в некоторых ситуациях на практике она может быть очень удобна.

Если `getInputPromise()` реждектится и вы при вызове `then` не указали обработчик ошибки, то ошибка будет отправлена в `outputPromise`:

~~~js
var outputPromise = getInputPromise().then(
	function (value) { }
	// второго обработчика нет!
);
~~~

Если `getInputPromise()` резолвится и вы при вызове `then` не указали обработчик успешной ситуации, то результат будет отправлен в `outputPromise`:

~~~js
var outputPromise = getInputPromise().then(
	null, // первого обработчика нет
	function (error) {}
);
~~~

Q предоставляет сокращение для такой формы записи в виде метода `fail`. Используйте его тогда, когда вы заинтересованы только в обработке ошибочного результата:

~~~js
var outputPromise = getInputPromise().fail(
	function (error) {}
);
~~~

Если вы пишете код под современные JS-движки или используете CoffeeScript, то вы можете писать название метода как `catch`. 

Также промисы имеют функцию `fin`, которая может использоваться в качестве блока `finally`. Обработчик в этом блоке вызывается тогда, когда промис либо резолвится, либо реджектится. Полученное значение всплывет в `outputPromise`, если обработчик `finally` не завершился с ошибкой. Если обработчик вернет промис, то всплытие будет задержано до разрешения этого промиса.

~~~js
var outputPromise = getInputPromise().fin(function () {
	// закрывает файловые дескрипторы, соединения и т.д.
});
~~~

* Если обработчик вернет значение, то оно будет проигнорировано.
* Если обработчик выбросит исключение, то исключение всплывет в `outputPromise`
* Если обработчик вернет промис, то всплытие будет задержано до его разшения. Разрешение промиса будет происходить по тем же правилам, что указаны в первых двух пунктах.

## Цепочки вызовов (Chaining)

Существует несколько способов чейнить промисы. Вы можете делать это как внутри, так и вне обработчиков. Два следующих примера эквивалентны.

~~~javascript
return getUsername().then(
	function (username) {
  	return getUser(username).then(
  		function (user) {
		    // Если мы пришли сюда, значит не случилось обшибок
		    // на прошлых шагах. Значение, которое вернет этот
		    // обработчик или ошибка, которую он бросит, разрешит
		    // промис, который мы вернули на первой строке.
		  }
	  )
	}
);
~~~

~~~javascript
return getUsername()
.then(function (username) {
    return getUser(username);
})
.then(function (user) {
    // Если мы пришли сюда, значит не случилось обшибок
    // на прошлых шагах. Значение, которое вернет этот
    // обработчик или ошибка, которую он бросит, разрешит
    // промис, который мы вернули на первой строке.
});
~~~

Единственная разница в том, что при использования первого способа вы можете обрабатывать все полученные значения промисов вследствия создания замыканий.

~~~javascript
function authenticate() {
    return getUsername()
    .then(function (username) {
        return getUser(username);
    })
    // тут мы применяем простой чейнинг, так как нам не нужен username на следующем шаге
    .then(function (user) {
        return getPassword()
        // а вот тут мы создаем замыкание, потому что нам нужен и user и password
        .then(function (password) {
            if (user.passwordHash !== hash(password)) {
                throw new Error("Can't authenticate");
            }
        });
    });
}
~~~

### Комбинация промисов

Вы можете превратить массив промисов в промис для для всего массива используя метод `all`.

~~~javascript
return Q.all([
    eventualAdd(2, 2),
    eventualAdd(10, 20)
]);
~~~

Полученный просим будет зарезолвлен тогда, когда будет зарезолвлены все его компоненты. Если же один из них будет зареджекчен, то весь промис будет зареджекчен.

Если у вас есть промис на массив, то вы можете использовать ``spread`` как замену ``then``. Эта функция позволяет "заполнить" результатами переданных просимов аргументы обработчика. Обработчик ошибки будет вызван при наступлении любой ошибки. 

~~~javascript
function eventualAdd(a, b) {
    return Q.spread([a, b], function (a, b) {
        return a + b;
    })
}
~~~

Метод ``spread`` вызывает ``all`` так что вы можете опустить all в цепочке.

~~~javascript
return getUsername()
.then(function (username) {
	  // возвращает массив, один из элементов которого - промис
    return [username, getUser(username)];
})
.spread(function (username, user) {
	// работаем с результатами выполнения
});
~~~

Метод ``all`` возвращает промис для массива значений. Когда этот промис разрешается, он будет содержать массив значений для кадого из исходных промисов в том порядке, в котором они стояли в массиве. Если один из входящих в массив промисов был зареджекчен, то общий промис будет зареджекчен немедленно, не дожидаясь результата остальных. Если вы хотите подождать момента, когда все промисы будут либо зареджекчены, либо зарезолвлены, то используйте метод ``allSettled``.

~~~javascript
Q.allSettled(promises)
.then(function (results) {
    results.forEach(function (result) {
        if (result.state === "fulfilled") {
        		// тут мы оказывается, если промис был зарезолвлен
            var value = result.value;
        } else {
        	  // а тут - если был зареджекчен
            var reason = result.reason;
        }
    });
});
~~~

### Последовательности

Если вы ходите запустить последовательно несколько функций, которые возвращают промисы, вы можете сделать это вручную:

~~~javascript
return foo(initialVal).then(bar).then(baz).then(qux);
~~~

Тем не менее, бывают ситуации, когда вам нужно запустить динамически сконструированную последовательность функций. Вы можете сделать это следующим образом:

~~~javascript
var funcs = [foo, bar, baz, qux];

var result = Q(initialVal);
funcs.forEach(function (f) {
    result = result.then(f);
});
return result;
~~~

Этот пример можно сделать немного короче, если использовать функцию ``reduce`` (учтите, что метод [method][reduce] для массивов представлен в спецификации ECMAScript 5):

[reduce]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce

~~~javascript
return funcs.reduce(function (soFar, f) {
    return soFar.then(f);
}, Q(initialVal));
~~~

Или же вы можете использовать этот супер-компактный вариант, использую статический метод `Q.when`:

~~~javascript
return funcs.reduce(Q.when, Q(initialVal));
~~~

## Обработка ошибок

Некоторым кажется не очевидным один аспект работы промисов. Рассмотрим его подробнее: если вы выбросите исключение в обработчике успешного результата функции (первый аргумент `then`), то оно не будет поймано обработчиком ошибки (второй аргумент `then`)

~~~javascript
return foo()
.then(function (value) {
    throw new Error("Can't bar.");
}, function (error) {
    // сюда мы придем только тогда, когда foo "упадет"
});
~~~

Чтобы понять, почему так происходит, попробуейте думать о промисе как о блоке ``try``/``catch``. Мы пытаемся выполнять функцию ``foo()`` как бы в блоке ``try`` и обработчик ошибки тут выступает в качестве блока ``catch``. Обработчик успешного разрешения промиса в данном случае выступает как код, идущий *после* блока ``try``/``catch``. Очевидно, что такой код нуждается в собственной обработке ошибок.  

В терминах промисов это значит, что вам нужно сделать цепочку вызовов с указанием обработчика ошибки:

~~~javascript
return foo()
.then(function (value) {
    throw new Error("Can't bar.");
})
.fail(function (error) {
    // сюда мы придем как в случае ошибки в foo (так как ошибка "всплывет"), 
    // так и в случае ошибки резолв-хендлера 
});
~~~

## Оповещения о прогрессе выполнения

В библиотеке реализована возможность промисам сообщать собственный прогресс выполнения, например, для долгих задач, таких как загрузка файла. Вы должны понимать, что не все промисы автоматически реализуют такую возможность. Но для тех промисов, что это делают, у вас есть возможсть получить прогресс используя третий параметр функции ``then``:

~~~javascript
return uploadFile()
.then(function () {
    // Тут мы успешно загрузили файл
}, function (err) {
    // Тут мы получаем причину ошибки загрузки файла
}, function (progress) {
    // Тут мы получаем оповещение о прогрессе в то время, пока файл загружается
});
~~~

Q представляет нам более короткую форму записи (похожее мы видели на примере функции `fail`):

~~~javascript
return uploadFile().progress(function (progress) {
    // Тут мы получаем оповещение о прогрессе
});
~~~

## Окончание цепочки промисов

Когда вы доходите до конца цепочки промисов, вы должны решить, хотите ли вы получить новый промис в качестве результата, или же вы хотите закончить цепочку. Если вы никак не используете полученный последний промис, то вы рискуете потерять какое-нибудь исключение по причине того, что промисы перехватывают ошибки.

Вместо того, чтобы возвращать последний промис вы можете закончить цепочку, вызвав метод `done()`.

Сравните:

~~~javascript
// возвращаем промис
return foo()
.then(function () {
    return "bar";
});
~~~

~~~javascript
foo()
.then(function () {
    return "bar";
})
.done();
~~~

Использование последнего варианта позволяет убедиться, что никакое исключение не будет потеряно в ходе обработки промиса. Если вы не обработали его в цепочке вызовов, то оно будет выброшено. Эта мера позволяет вам увидеть проблемы в коде и среагировать на них.

## С чего начать?

Все, что было написано выше было рассчитано на то, что вы уже взяли где-то готовый промис. Давайте теперь посмотрим, как мы можем создать промис самостоятельно.


### Используем ``Q.fcall``

Вы можете вернуть промис для какого-то значения, используя ``Q.fcall``. В следующем примере мы получим промис для значения 10.

~~~javascript
return Q.fcall(function () {
    return 10;
});
~~~

Также вы можете использовать ``fcall`` для получения промиса исключения:

~~~javascript
return Q.fcall(function () {
    throw new Error("Can't do it");
});
~~~

Как нам обещает название, ``fcall`` может быть использован для вызова функций и даже для вызова тех функций, которые возвращают промисы:

~~~javascript
return Q.fcall(eventualAdd, 2, 2);
~~~

### Использование Deferreds

Если вы имеете дело с асинхронными функциями, которые используют коллбек, а не промисы, вы можете использовать существующие шоткаты, которые представляет Q (например ``Q.nfcall``). Тем не менее, в большинстве случаев вам будет удобнее воспользоваться объектами `deferred`. 

~~~javascript
var deferred = Q.defer();
FS.readFile("foo.txt", "utf-8", function (error, text) {
    if (error) {
        deferred.reject(new Error(error));
    } else {
        deferred.resolve(text);
    }
});
return deferred.promise;
~~~

Обработе внимание, что `deferred` может быть разрешен при помощи значения или другого промиса.

Давайте на примере посмотрим, как мы можем использовать промисы на практике. Ниже приведена упрощенная реализация ``Q.delay``.

~~~javascript
function delay(ms) {
    var deferred = Q.defer();
    setTimeout(deferred.resolve, ms);
    return deferred.promise;
}
~~~

В следующем примере рассмотрим реализацию ``Q.timeout``.

~~~javascript
function timeout(promise, ms) {
    var deferred = Q.defer();
    Q.when(promise, deferred.resolve);
    delay(ms).then(function () {
        deferred.reject(new Error("Timed out"));
    });
    return deferred.promise;
}
~~~

Не обойдем вниманием и отправку оповещений о прогрессе выполнения с использованием метода ``deferred.notify``.

Для иллюстрации, давайте напишем простую обертку над браузерным XMLHttpRequest.

~~~javascript
function requestOkText(url) {
    var request = new XMLHttpRequest();
    var deferred = Q.defer();

    request.open("GET", url, true);
    request.onload = onload;
    request.onerror = onerror;
    request.onprogress = onprogress;
    request.send();

    function onload() {
        if (request.status === 200) {
            deferred.resolve(request.responseText);
        } else {
            deferred.reject(new Error("Status code was " + request.status));
        }
    }

    function onerror() {
        deferred.reject(new Error("Can't XHR " + JSON.stringify(url)));
    }

    function onprogress(event) {
        deferred.notify(event.loaded / event.total);
    }

    return deferred.promise;
}
~~~

Давайте посмотрим, как мы можем использовать получившуюся ``requestOkText``:

~~~javascript
requestOkText("http://localhost:3000")
.then(function (responseText) {
		// Если HTTP запрос вернет код 200 OK, то мы логируем текст ответа
    console.log(responseText);
}, function (error) {
    // Если в ходе запроса произошла ошибка или вернулся не 200 OK, то мы логируем ошибку
    console.error(error);
}, function (progress) {
    // Логируем прогресс выполнения запроса:
    console.log("Request progress: " + Math.round(progress * 100) + "%");
});
~~~

## Источники

* [Официальная документация](https://github.com/kriskowal/q/blob/master/README.md)