---
layout: post
title:  "Реактивный UI с использованием виртуальных деревьев"
date:   2014-01-03 12:00
languages: Javascript
categories:
---

## О материале

Я решил написать серию статей на тему "Реактивный UI с использованием виртуальных деревьев" и собрать в ней общую теорию и практику данного подхода к проектированию интерактивных приложений.

В первой статье цикла я хотел бы рассмотреть общую теорию и эволюцию подходов к обеспечению "рекативности" — реакции приложения на действия пользователей и изменение данных. 

Основная речь пойдет про веб и язык программирования JavaScript. Мы посмотрим на то, как обеспечивает реактивность Backbone, Angular, EmberJS и ReactJS. В следующих статьях я постараюсь более полно раскрыть теорию и практику разработки реактивных UI. Итак, поехали!

## Эволюция походов проектирования приложений

### Простой подход

Простым подходом можно назвать ситуацию, когда разработчик пытается решить все задачи руками без какой-либо магии. В мире JavaScript простой подход к проектированию UI можно рассмотреть на примере библиотеки Backbone:

(Пример взят из TodoMVC на Backbone: http://todomvc.com/architecture-examples/backbone/)

~~~js
app.AppView = Backbone.View.extend({
    render: function () {
        var completed = app.todos.completed().length;
        var remaining = app.todos.remaining().length;

        if (app.todos.length) {
            this.$main.show();
            this.$footer.show();

            this.$footer.html(this.statsTemplate({
                completed: completed,
                remaining: remaining
            }));

            this.$('#filters li a')
            .removeClass('selected')
            .filter('[href="#/' + (app.TodoFilter || '') + '"]')
            .addClass('selected');
        } else {
            this.$main.hide();
            this.$footer.hide();
        }

        this.allCheckbox.checked = !remaining;
    },

    // Add a single todo item to the list by creating a view for it, and
    // appending its element to the `<ul>`.
    addOne: function (todo) {
        var view = new app.TodoView({ model: todo });
        this.$list.append(view.render().el);
    },

    // Add all items in the **Todos** collection at once.
    addAll: function () {
        this.$list.html('');
        app.todos.each(this.addOne, this);
    },

    filterOne: function (todo) {
        todo.trigger('visible');
    },

    filterAll: function () {
        app.todos.each(this.filterOne, this);
    }
});
~~~

На что следует обратить внимание?

* Явные манипуляции с элементами DOM. Прямая установка свойств.
* Наличие методов `addOne` и `addAll`. Данные методы используются для реагирования UI на изменение данных.

#### Достоинства

* Полное управление ситуацией. Можно делать что угодно и когда угодно. Прямые манипуляции с деревом дают полную свободу действий.
* Скорость работы. Программист вручную прописывает все манипуляции с деревом и может контролировать и корректировать определенные нюансы производительности.

#### Недостатки

* Все манипуляции с деревом необходимо описывать вручную. Для каждого из способов изменения данных требуется писать код, отражающий это изменение на визуальное дерево.
* Больше кода порождает больше ошибок. Разработчики в простой модели должны быть очень бдительными.
* Состояние приложения невозможно восстановить на любой произвольный момент.

### Подход с использованием технологий data-binding

Data-binding - технология автоматической синхронизации данных между моделью данных и визуальным деревом. Обычно в такой архитектуре данные рассматриваются как единственный источник "правды" для приложения. Что скрывается за этой фразой?

За этой фразой скрывается целый пласт технологий, который позволяют разработчику указать шаблоны для UI и правила биндинга данных — а фреймворк сам творит свою магию и обновляет UI при изменении данных. 

Data-binding подход разделяется на два больших направления. Если подходить к вопросу поверхностно, то можно сказать, что различаются они вот так:

* Plain Object архитектура. В такой архитектуре модель данных представляется набором примитивных объектов языка (например, POJO — Plain Old JavaScript Object, как любят говорить авторы фреймворков).
* Архитектура на толстых моделях.

#### Data-binding на простых объектах

В данной архитектуре модели данных — примитивные объекты и их можно модифицировать, удалять и всячески над ними издеваться. Как же в такой неразберихе приложению узнать о том, какие данные поменялись и как?

Ответ очень прост, мы будет **наблюдать**. Для простоты объяснения предположим, что у нас есть глобальный объект с нашими данными о некоем человеке — `User`. Мы хотим извернуться и вывести на экран имя и фамилию этого человека, и при этом менять наше визуальное представление вместе с изменением данных.

~~~html
<body>{{ User ? User.first_name + User.last_name : 'Unknown person' }}</body>
~~~

В этом вымышленном куске кода я пользуюсь символами `{{ .. }}` для объявления "блока магии", который будет обслуживаться фреймворком. Итак, что нужно сделать для того, чтобы эта магия заработала?

Для работы этой магии мы должны периодически вычислять значение выражения, стоящего внутри `{{ ... }}` и менять визуальное дерево в том случае, когда результат выражения изменился. Вот так вот просто!

В простейшем случае это можно делать по таймеру, например, раз в одну секунду вычислять все такие блоки и обновлять визуальное дерево. На практике, конечно, механизм проверки таких блоков действует несколько умнее, но это сильно зависит от реализации конкретного фреймворка.

В качестве подопытного в этой категории мы рассмотрим веб-фреймворк AngularJS. Заглянем в его TodoMVC (https://github.com/tastejs/todomvc/blob/gh-pages/architecture-examples/angularjs/index.html):

~~~html
<section id="todoapp" ng-controller="TodoCtrl">
    <header id="header">
        <h1>todos</h1>
        <form id="todo-form" ng-submit="addTodo()">
            <input id="new-todo" placeholder="What needs to be done?" ng-model="newTodo" autofocus>
        </form>
    </header>
    <section id="main" ng-show="todos.length" ng-cloak>
        <input id="toggle-all" type="checkbox" ng-model="allChecked" ng-click="markAll(allChecked)">
        <label for="toggle-all">Mark all as complete</label>
        <ul id="todo-list">
            <li ng-repeat="todo in todos | filter:statusFilter track by $index" ng-class="{completed: todo.completed, editing: todo == editedTodo}">
                <div class="view">
                    <input class="toggle" type="checkbox" ng-model="todo.completed">
                    <label ng-dblclick="editTodo(todo)">{{todo.title}}</label>
                    <button class="destroy" ng-click="removeTodo(todo)"></button>
                </div>
                <form ng-submit="doneEditing(todo)">
                    <input class="edit" ng-trim="false" ng-model="todo.title" todo-escape="revertEditing(todo)" ng-blur="doneEditing(todo)" todo-focus="todo == editedTodo">
                </form>
            </li>
        </ul>
    </section>
    <footer id="footer" ng-show="todos.length" ng-cloak>
        <span id="todo-count"><strong>{{remainingCount}}</strong>
            <ng-pluralize count="remainingCount" when="{ one: 'item left', other: 'items left' }"></ng-pluralize>
        </span>
        <ul id="filters">
            <li>
                <a ng-class="{selected: status == ''} " href="#/">All</a>
            </li>
            <li>
                <a ng-class="{selected: status == 'active'}" href="#/active">Active</a>
            </li>
            <li>
                <a ng-class="{selected: status == 'completed'}" href="#/completed">Completed</a>
            </li>
        </ul>
        <button id="clear-completed" ng-click="clearCompletedTodos()" ng-show="completedCount">Clear completed ({{completedCount}})</button>
    </footer>
</section>
~~~

Как можно видеть из примера, вся архитектура Angular построена на тех самых наблюдениях. Посмотрите подробнее на этот чудесный код:

~~~html
<li ng-repeat="todo in todos | filter:statusFilter track by $index" ng-class="{completed: todo.completed, editing: todo == editedTodo}">
    ...
</li>
~~~

Директива `ng-repeat` — отличный образец наблюдательной магии Angular. Она вычисляет выражение, записанное в значении атрибута и для каждого элемента из полученного массива объектов создает визуальный элемент исходя из внутреннего шаблона. 

Директива `ng-class` также позволяет наблюдать за выражением, указанным в атрибуте и менять классы на элементе визуального дерева в зависимости от результата вычисления. Потрясающе!

##### Достоинства

* Модель данных — источник правды. Это позволяет значительно уменьшить сложность построения приложения за счет того, что разработчику не требуется описывать большую часть логики применения изменений данных к визуальному дереву. 
* Декларативный UI. Пишем меньше кода — делаем меньше ошибок. 

##### Недостатки

* Для работы технологии в коде фреймворка или приложения требуется разработка способов реагирования на изменение данных (вспомним `ng-class`). Для каждого из возможных способов взаимодействия требуется реализация своего функционального блока. В Angular такие штуки называются *директивами*.
* Производительность модели начинает проседать, когда под наблюдением оказывается большое число выражений, ведь нам нужно вычислять новые значения для всех них каждый раз!

#### Data-binding на толстых моделях

Альтернативой POJO в мире современных визуальных фреймворков является биндинг на толстых моделях.

Толстой моделью я называю объект, который может оповещать наблюдателей о собственных изменениях (вспоминаем http://en.wikipedia.org/wiki/Observer_pattern).

В простейшем случае в качестве толстой модели можно рассмотреть объект, имеющий два метода: `get` и `set`, которые позволяют нам задавать и получать поля объекта. Рассмотрим пример из документации Ember:

~~~js
App.Person = Ember.Object.extend({
  helloWorld: function() {
    alert("Hi, my name is " + this.get('fullName'));
  }
});

var tom = App.Person.create({
  fullName: "Tom Dale"
});

tom.helloWorld(); // alerts "Hi my name is Tom Dale"
~~~

Объект с таким сложным API уже никак не назовешь POJO, но у него есть одно замечательное свойство — он может оповещать слушателей об изменении себя любимого, когда кто-то вызывает метод `set`:

~~~js
person.addObserver('fullName', function() {
  // делаем что-нибудь при изменении fullName
});
~~~

Это позволяет нам вместо периодического вычисления всех наблюдаемых блоков кода (вспомните, чем мы занимались в AngularJS) просто реагировать на изменения моделей, когда кто-то говорит `set`. В сочетании с такими возможностями как **вычисляемые поля моделей** и мощными шаблонами это дает нам еще один способ реагирования на изменения данных в нашем приложении.

##### Преимущества

* Тратим меньше ресурсов для вычисления изменений UI.
* В нашем распоряжении "толстые модели", в которые мы всегда можем добавить расширенную логику, валидации, преобразование данных, персистентность и прочие приятные мелочи. 

##### Недостатки

* Появляются лишние тяжелые сущности в виде моделей, которые необходимо поддерживать. Это уменьшает гибкость кода и повышает порог вхождения.
* Сложно разрешаются ситуации, когда поле в шаблоне зависит от нескольких моделей сразу.
* Необходимость работать с геттерами и сеттерами и помнить о том, что каждое твое изменение модели запускает "магию".

#### Object.observe

Говоря о двух альтернативах data-binding будет грехом не упомянуть о новой возможности стандарта ECMAScript 6 — [Object.observe](http://updates.html5rocks.com/2012/11/Respond-to-change-with-Object-observe).

Эта штука обещает если не примирить два лагеря, то точно дать возможность стать ближе друг к другу. Если говорить коротко, то observe дает возможность подписываться на изменения POJO так же, как мы подписывались на толстую модель, то есть реализует для них паттерн "Observer"!

~~~js
var beingWatched = {};

// Определяем коллбек-функцию, которая будет получать оповещения об изменениях
function somethingChanged(changes) {
    // Делаем тут что-нибудь
}

Object.observe(beingWatched, somethingChanged);
~~~

Этот подход может частично нивелировать те проблемы, которые мы имеем в подходе с толстыми моделями. На сегодняшний момент данных функционал уже доступен в последних версиях V8 (Chrome, Safari, Opera) и [скоро](https://bugzilla.mozilla.org/show_bug.cgi?id=800355) будет доступен в Firefox. 

Чтож, осталось подождать и посмотреть, как `Object.observe` изменит мир дата-биндинга. Если же вы работаете с каким-нибудь другим языком и нем реализованы подобные возможности — смело беритесь перо и расскажите нам, как можно использовать эту технологию для облегчения разработки!

### Виртуальные визуальные деревья

Все это время мы обсуждали с вами технологии создания интерфейсов, которые реагируют на изменения данных тем или иным способом. Давайте посмотрим на еще одну интересную реализацию идеи реактивного UI, который явила миру компания Facebook в своем продукте [ReactJS](http://facebook.github.io/react/).

Начнем с того, что ребята сделали одну очень интересную и необычную вещь. Вместо того, чтобы работать с DOM браузера, как делают все остальные, они взяли и создали свои объекты дерева!

Так, например, браузерный элемент `<div>` соответствует объекту `React.DOM.div`, а тег `<a>` соответствует `React.DOM.a`. Зачем они это сделали? Зачем плодить сущности и создавать свои объекты, когда можно пользоваться [document.createElement](https://developer.mozilla.org/ru/docs/DOM/document.createElement)?

Ответ кроется в двух вещах:

* Свои элементы визуального дерева создаются быстрее и "стоят" дешевле, потому что они не имеют нативного представления.
* Свои элементы можно расширить различными функциями, которых нет у браузерных DOM-элементов.

Не буду больше вас томить и покажу пример из документации ReactJS:

~~~js
var Timer = React.createClass({

  getInitialState: function() {
    return {secondsElapsed: 0};
  },

  tick: function() {
    this.setState({secondsElapsed: this.state.secondsElapsed + 1});
  },

  componentDidMount: function() {
    this.interval = setInterval(this.tick, 1000);
  },

  componentWillUnmount: function() {
    clearInterval(this.interval);
  },

  render: function() {
    return (
      React.DOM.div({style: {'background-color': 'red'}}, 
        "Seconds Elapsed: ", this.state.secondsElapsed)
    );
  }
});

React.renderComponent(Timer(), mountNode);
~~~

В терминологии ReactJS мы только что создали новый **компонент** Timer. Данный компонент занимается тем, что ежесекундно обновляет свое **состояние** при помощи функции `tick` и перерисовывается при изменении этого состояния.

Внимательный читатель уже заметил, что основная магия заключена в методе `render`:

~~~js
render: function() {
    return React.DOM.div(null, "Seconds Elapsed: ", this.state.secondsElapsed);
}
~~~

Посмотрите, метод `render` возвращает нам экземпляр визуального дерева, состоящий в данном случае из одного элемента `div` без атрибутов, у которого детьми будут две текстовые ноды:

1. "Seconds Elapsed: "
2. this.state.secondsElapsed

Дальше работает специальная "магия", которая отображает получившееся визуальное дерево ReactJS в дерево DOM.

Давайте попробуем формализовать, что же мы на текущий момент поняли:

1. Мы можем создавать свои компоненты, из которых можно собирать свое виртуальное визуальное дерево.
2. Компоненты имеют **опции** (props) и **внутреннее состояние** (state).
3. Компоненты предоставляют метод `render`, который должен вернуть визуальное дерево, соответствующее текущему набору **опций** и **внутреннему состоянию**.
4. ReactJS сам заботится о том, чтобы наше виртуальное дерево отразилось на DOM.

Эти четыре пункта описывают всю суть модели React. Попробую объяснить модель ReactJS чуть более подробно.

Представьте, что ваше приложение имеет конфигурационный файл, в который вы кладете описание состояние приложения и модели данных. Далее вы создаете большую функцию `render`, которая возвращает визуальное дерево в соответствии с этой конфигурацией. Каждый раз, когда вы хотите привести ваше приложение в новое состояние (например, показать новое окно), вы просто меняете конфигурацию и снова запускаете `render`.

Разумеется, данный утрированный подход полной перерисовки в реальной жизни будет довольно медленным и я вам его использовать в своих приложениях не советую. Тем не менее, это хороший способ осознать, как все работает.

В реальности ReactJS старается оптимизировать этой подход следующим образом:

* Вам не обязательно вносить изменения в **глобальный стейт** приложения (наш конфигурационный файл), чтобы внести небольшие изменения в приложение. Вместо этого вы можете установить **состояние** отдельно взятому компоненту, что приведет к перерисовке только его поддерева.
* Используется специальный Diff-алгоритм, который позволяет оптимизировать рендеринг и сделать минимальное число изменений в ваше визуальное дерево.
* Вы можете сами на уровне компонента отслеживать ситуации, когда нужно обновлять свое визуально дерево, а когда нет.

#### Преимущества

* Все преобразования данных выполняются одним и тем же способом.
* State и Props - POJO, использование толстых моделей не обязательно.
* Маленькое количество сущностей обеспечивает быстрое вхождение.
* ReactJS сам выполняет преобразование из одного состояние визуального дерева в другое самым оптимальным путем. Это также приводит к тому, что сокращается объем кода.

#### Недостатки

* Возможны проблемы производительности при плохом проектировании приложения.

## Выводы

В данной статье я рассмотрел существующие подходы к созданию реактивных UI. В следующих статьях я буду дальше рассматривать технологию виртуальных деревьев и расскажу, как с ее помощи решаются типичные задачи.

Спасибо всем за внимание!