---
layout: post
title:  "Почему вы должны писать на языке с явной или опциональной типизацией"
date:   2014-11-30 21:00
languages: Rust
categories:
---

Уже много лет я пишу на модных языках с динамической типизацией. Сначала был Python, затем Ruby и JavaScript, потом добавилось немного Erlang. Все эти языки — разные и каждый них прекрасен по-своему, 

И есть у них одна общая черта — они все основаны на динамической типизации. Нельзя однозначно сказать, плохо это или хорошо, ведь динамическая типизация позволяет нам делать сумасшедшие и прекрасные вещи, экономить строчки кода и делать язык более выразительным. Вспоминаем всю силу магии Ruby:

~~~ruby
User
  .find_by_name_and_force("Anakin Skywalker", :light)
  .update(
    name: "Dart Vaider", 
    force: :dark
  )
~~~

Сложно сделать подобные вещи **еще** более выразительными.

Я думаю, что именно чудовищная гибкость и свобода в типизации помогли JavaScript стать таким популярным языком. Новичкам очень легко "въехать" в язык и начать делать на нем что-то прекрасное.

Тем не менее, не смотря на всю силу и выразительность, у такого подхода есть и свои недостатки.

Я несколько лет работал тимлидом и мне довелось поработать в нескольких командах с прекрасными разработчиками. На последнем месте работы мы разрабатывали JavaScript SDK и продукты для платформы интерактивного телевидения. Это был поистине сложный и громоздкий проект, сочетающий в себе большое количество бизнес-логики, математики, сложных, но удобных абстракций.

Работа и поддержки подобных проектов перевернула мое представление о том, на каком языке я хочу писать.

Изначально работы над проектом доставляет удовольствие: нужно писать новый код, конфликтов и пересекающихся задач мало и каждый занят своим делом. Это время — самое прекрасное для любой команды. Но позднее, когда проект уже находится на более "взрослой" стадии, начинаются проблемы. Кодовая база постепенно увеличивается в размерах и разработчикам уже сложно удержать в голове свои подсистемы. Приходят задачи на переделку или новый функционал, которые требуют рефакторинга.

И в этот самый момент проекты на динамических языках программирования радовать перестают. Опечатки, изменившиеся сигнатуры функций и бизнес-логики, недопереименованные переменные, null/nil/undefined, изменные коллегой структуры объектов — это неполные перечень ошибок, с которыми сталкиваются при рефекторинге и написании кода любые разработчики на динамических языках. Все это злит, и, самое главное, отнимает огромное количество времени и сил.

Какое решение таких проблем предлагают нам святейшие? Они предлагают нам тесты!

Да, разумеется, тесты в разумном количестве необходимы и я не собираюсь этого отрицать и сам их пишу. Однако, на моей практике часто встречаются ситуации, когда тесты не помогают в работе:

1. Тесты на эту часть кода просто не написаны.
2. Написаны юнит-тесты, но нет интеграционных тестов, которые помогли бы выловить ошибки на стыках модулей.
3. Рефакторинг ломает тесты, но где-то глубоко, и глупую опечатку или ошибку все-равно нужно долго и упорно искать.
4. Рефакторинг ломает множество тестов и это ничуть не помогает в понимании ошибки.

Поймите меня правильно, тесты — потрясающий инструмент. Но я считаю, что писать и поддерживает тесты только для ограждения от тех типов ошибок, которые может проверить машина — довольно глупо.

Системы типов в явно типизируемых языках как раз для того и нужны, чтобы **доказывать** отсутствие в программе определенного нежелательного поведения. И речь идет не только о глупых ошибках или опечатках, речь идет о целых классах ошибок логики, структуры данных и взаимодействия составных частей вашей программы.

Давайте рассмотрим простейшую функцию на JavaScript и попробуем понять, как явная типизация может помочь нам избежать ошибок в нашей программе.

Менеджер Перт приходит и просит нас написать функцию, которая позволит складывать два числа. Задача, конечно, непростая, но мы справимся:

~~~js
function sum(a, b) {
  return a + b;
}
~~~

Функция написана, заказчик доволен. Идем домой пить напиток из трав и заниматься медитацией.

На следующий день заказчик просит нас прикрутить к этой функции HTML-форму, через которую можно ввести числа и получить их сумму. Опять-таки не беда, заказываем на oDesk верстку формы на HTML5 + CSS3 + БЕМ + Responsive + Mobile First и дописываем к нашей программе код:

~~~js
var result = sum(
  document.getElementById("inputA").value,
  document.getElementById("inputB").value,
)

document.getElementById("result").innerText = result;
~~~

Пишем в наши поля ввода два числа, 1 и 2 и проверяем работу нашей функции:

~~~
12
~~~

Хмм, что? Я, конечно, подзабыл математику, но два числа сложить все еще могу. И результат у меня в голове получается другой.

Все дело в том, что поле `value` у Input отдает нашей функции результат типа "string" и JavaScript заботливо склеивает нам две строки "1" и "2" вместо того, чтобы сложить два числа.

Это, конечно, утрированный пример, но в более серьезной форме такие ошибки появляются в наших программах ежедневно.

Как JavaScript-разработчику справляться с такими проблемам в современном мире? Мой совет таков — убедите ваше руководство и себя в том, что следующий проект вам нужно начать писать на TypeScript или его аналогах (Flow, AtScript).

~~~ts
function sum(a: number, b: number): number {
  return a + b;
}

sum(1, 2) // Ok
sum(1, "2") // Error!
~~~

Используя явную типизацию вы смогли на этапе компиляции предотвратить эту ошибку и освободить силы, затраченные на ее поиски, на созидание!

Я уже перестал считать, сколько часов на рефакторинг сэкономил мне TypeScript в моем текущем домашнем (но не очень маленьком) проекте. Начать разрабатывать на TypeScript очень легко:

1. Поддержка есть во всех популярных IDE. Превосходная поддержка в IDE от JetBrains с автокомплитом и рефакторингами.
2. Код на JavaScript является валидным кодом на TypeScript. Это одно из важнейших преимуществ языка. Вы можете переводить проект на TypeScript постепенно, указывая типы там, где вам необходимо. 
3. Типизация опциональна! Если вам нужно сделать какую-то штуку, которую сложно уложить в рамки существующей системы типов, вы можете просто не указывать некоторые типы. Это позволить вам сохранить баланс между гибкостью и строгостью вашего кода.
4. Существует огромная база типизаций для большинства важных и известных библиотек — [DefinitelyTyped](http://definitelytyped.org/tsd/). Типизируйте ваш React,  Angular,  Jquery,  Underscore или Lodash.

Попробуйте, вам понравится!