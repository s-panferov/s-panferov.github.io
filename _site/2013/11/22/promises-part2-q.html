<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Promise и Deferred. Часть 2. Библиотека Q.</title>
    <meta name="description" content="Personal web blog about software development and code design.
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://panferov.me/2013/11/22/promises-part2-q.html">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Stanislav Panferov</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About me</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Promise и Deferred. Часть 2. Библиотека Q.</h1>
    <p class="post-meta">Nov 22, 2013</p>
  </header>

  <article class="post-content">
    <p>Сегодня в нашем обзоре рассмотрим библиотеку промисов Q. Данная библиотека предоставляет каноническую (на мой взгляд) и самую полную реализацию промисов. </p>

<p>Дальше я во многом буду повторять официальную документацию к библиотеке, но постараюсь попутно объяснять вещи более понятным языком, чем это делает ман.</p>

<!--more-->

<p>Промисы имеют метод <code>then</code>, который вы можете использовать для того, чтобы получить вычисленное значение или ошибку. Если вычисление значение пройдет успешно, то будет вызвана первая переданная в метод <code>then</code> функция. Если же в процессе вычисления будет выброшено исключение, то будет вызвана функция, которую можно передать вторым аргументом.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>promiseMeSomething().then(
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#080;font-weight:bold">function</span> (value) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        }, 
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>        <span style="color:#080;font-weight:bold">function</span> (reason) {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>        }
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>);
</pre></div>
</div>
</div>

<p>Важно учесть, что разрешение (resolution) промиса всегда выполняется асинхронно в следующем тике. Это гарантирует вам, что <code>then</code> вернет управление в ваш код до вызова любого из переданных обработчиков.</p>

<p>Дальше мы рассмотрим различные особенности промисов, которые предоставляет нам библиотека Q.</p>

<h2 id="propagation">Всплытие (Propagation)</h2>

<p>Вы можете запомнить результат выполнения метода <code>then</code>. Библиотека устроена таким образом, что результатом выполнения метода <code>then</code> будет новый промис с любопытными свойствами:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> outputPromise = getInputPromise().then(
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#080;font-weight:bold">function</span> (input) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>                <span style="color:#777">// function success</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>        }, 
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>        <span style="color:#080;font-weight:bold">function</span> (reason) {
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>                <span style="color:#777">// function error</span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>        }
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>);
</pre></div>
</div>
</div>

<p><code>outputPromise</code> становится промисом для результата выполнения одного из обработчиков <code>getInputPromise</code>. Так как выполниться может только один из них (функция либо вернет значение, либо выбросит исключение), то только одна функция будет источником результата для <code>outputPromise</code>. Назовем сработавшую функцию (success или error) “хендлером” и посмотрим на правила, которыми руководствуется библиотека Q для разрешения <code>outputPromise</code></p>

<ul>
  <li>Если хендлер успешно вернул значение, то <code>outputPromise</code> будет разрешен (далее “зарезолвлен”, от слова “resolve”) с этим значением и вызовом первого, “успешного” обработчика.</li>
  <li>Если хендлер выбросил исключение, то <code>outputPromise</code> будет разрешен с вызовом второго обработчика (далее “зареджекчен”, от слова “reject”), обработчика ошибки.</li>
  <li>Существует еще одна любопытная возможность. Если хендлер вернет промис, то <code>outputPromise</code> “превратится” в него. Эта особенность сложна для понимания, но в некоторых ситуациях на практике она может быть очень удобна.</li>
</ul>

<p>Если <code>getInputPromise()</code> реждектится и вы при вызове <code>then</code> не указали обработчик ошибки, то ошибка будет отправлена в <code>outputPromise</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> outputPromise = getInputPromise().then(
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#080;font-weight:bold">function</span> (value) { }
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        <span style="color:#777">// второго обработчика нет!</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>);
</pre></div>
</div>
</div>

<p>Если <code>getInputPromise()</code> резолвится и вы при вызове <code>then</code> не указали обработчик успешной ситуации, то результат будет отправлен в <code>outputPromise</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> outputPromise = getInputPromise().then(
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#069">null</span>, <span style="color:#777">// первого обработчика нет</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        <span style="color:#080;font-weight:bold">function</span> (error) {}
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>);
</pre></div>
</div>
</div>

<p>Q предоставляет сокращение для такой формы записи в виде метода <code>fail</code>. Используйте его тогда, когда вы заинтересованы только в обработке ошибочного результата:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> outputPromise = getInputPromise().fail(
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#080;font-weight:bold">function</span> (error) {}
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>);
</pre></div>
</div>
</div>

<p>Если вы пишете код под современные JS-движки или используете CoffeeScript, то вы можете писать название метода как <code>catch</code>. </p>

<p>Также промисы имеют функцию <code>fin</code>, которая может использоваться в качестве блока <code>finally</code>. Обработчик в этом блоке вызывается тогда, когда промис либо резолвится, либо реджектится. Полученное значение всплывет в <code>outputPromise</code>, если обработчик <code>finally</code> не завершился с ошибкой. Если обработчик вернет промис, то всплытие будет задержано до разрешения этого промиса.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> outputPromise = getInputPromise().fin(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>        <span style="color:#777">// закрывает файловые дескрипторы, соединения и т.д.</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
</pre></div>
</div>
</div>

<ul>
  <li>Если обработчик вернет значение, то оно будет проигнорировано.</li>
  <li>Если обработчик выбросит исключение, то исключение всплывет в <code>outputPromise</code></li>
  <li>Если обработчик вернет промис, то всплытие будет задержано до его разшения. Разрешение промиса будет происходить по тем же правилам, что указаны в первых двух пунктах.</li>
</ul>

<h2 id="chaining">Цепочки вызовов (Chaining)</h2>

<p>Существует несколько способов чейнить промисы. Вы можете делать это как внутри, так и вне обработчиков. Два следующих примера эквивалентны.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> getUsername().then(
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>        <span style="color:#080;font-weight:bold">function</span> (username) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>          <span style="color:#080;font-weight:bold">return</span> getUser(username).then(
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>                  <span style="color:#080;font-weight:bold">function</span> (user) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>                    <span style="color:#777">// Если мы пришли сюда, значит не случилось обшибок</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>                    <span style="color:#777">// на прошлых шагах. Значение, которое вернет этот</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>                    <span style="color:#777">// обработчик или ошибка, которую он бросит, разрешит</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                    <span style="color:#777">// промис, который мы вернули на первой строке.</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>                  }
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>          )
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>        }
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>);
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> getUsername()
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (username) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">return</span> getUser(username);
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>})
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (user) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span style="color:#777">// Если мы пришли сюда, значит не случилось обшибок</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    <span style="color:#777">// на прошлых шагах. Значение, которое вернет этот</span>
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    <span style="color:#777">// обработчик или ошибка, которую он бросит, разрешит</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    <span style="color:#777">// промис, который мы вернули на первой строке.</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>});
</pre></div>
</div>
</div>

<p>Единственная разница в том, что при использования первого способа вы можете обрабатывать все полученные значения промисов вследствия создания замыканий.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">authenticate</span>() {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">return</span> getUsername()
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    .then(<span style="color:#080;font-weight:bold">function</span> (username) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        <span style="color:#080;font-weight:bold">return</span> getUser(username);
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    })
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span style="color:#777">// тут мы применяем простой чейнинг, так как нам не нужен username на следующем шаге</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    .then(<span style="color:#080;font-weight:bold">function</span> (user) {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>        <span style="color:#080;font-weight:bold">return</span> getPassword()
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>        <span style="color:#777">// а вот тут мы создаем замыкание, потому что нам нужен и user и password</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        .then(<span style="color:#080;font-weight:bold">function</span> (password) {
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>            <span style="color:#080;font-weight:bold">if</span> (user.passwordHash !== hash(password)) {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>                <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Can't authenticate</span><span style="color:#710">&quot;</span></span>);
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>            }
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        });
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>    });
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>}
</pre></div>
</div>
</div>

<h3 id="section">Комбинация промисов</h3>

<p>Вы можете превратить массив промисов в промис для для всего массива используя метод <code>all</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> Q.all([
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    eventualAdd(<span style="color:#00D">2</span>, <span style="color:#00D">2</span>),
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    eventualAdd(<span style="color:#00D">10</span>, <span style="color:#00D">20</span>)
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>]);
</pre></div>
</div>
</div>

<p>Полученный просим будет зарезолвлен тогда, когда будет зарезолвлены все его компоненты. Если же один из них будет зареджекчен, то весь промис будет зареджекчен.</p>

<p>Если у вас есть промис на массив, то вы можете использовать <code>spread</code> как замену <code>then</code>. Эта функция позволяет “заполнить” результатами переданных просимов аргументы обработчика. Обработчик ошибки будет вызван при наступлении любой ошибки. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">eventualAdd</span>(a, b) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">return</span> Q.spread([a, b], <span style="color:#080;font-weight:bold">function</span> (a, b) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>        <span style="color:#080;font-weight:bold">return</span> a + b;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    })
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
</div>

<p>Метод <code>spread</code> вызывает <code>all</code> так что вы можете опустить all в цепочке.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> getUsername()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (username) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>          <span style="color:#777">// возвращает массив, один из элементов которого - промис</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span style="color:#080;font-weight:bold">return</span> [username, getUser(username)];
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>})
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>.spread(<span style="color:#080;font-weight:bold">function</span> (username, user) {
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>        <span style="color:#777">// работаем с результатами выполнения</span>
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>});
</pre></div>
</div>
</div>

<p>Метод <code>all</code> возвращает промис для массива значений. Когда этот промис разрешается, он будет содержать массив значений для кадого из исходных промисов в том порядке, в котором они стояли в массиве. Если один из входящих в массив промисов был зареджекчен, то общий промис будет зареджекчен немедленно, не дожидаясь результата остальных. Если вы хотите подождать момента, когда все промисы будут либо зареджекчены, либо зарезолвлены, то используйте метод <code>allSettled</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>Q.allSettled(promises)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (results) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    results.forEach(<span style="color:#080;font-weight:bold">function</span> (result) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        <span style="color:#080;font-weight:bold">if</span> (result.state === <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">fulfilled</span><span style="color:#710">&quot;</span></span>) {
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>                        <span style="color:#777">// тут мы оказывается, если промис был зарезолвлен</span>
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>            <span style="color:#080;font-weight:bold">var</span> value = result.value;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>        } <span style="color:#080;font-weight:bold">else</span> {
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>                  <span style="color:#777">// а тут - если был зареджекчен</span>
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>            <span style="color:#080;font-weight:bold">var</span> reason = result.reason;
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>        }
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    });
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>});
</pre></div>
</div>
</div>

<h3 id="section-1">Последовательности</h3>

<p>Если вы ходите запустить последовательно несколько функций, которые возвращают промисы, вы можете сделать это вручную:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> foo(initialVal).then(bar).then(baz).then(qux);
</pre></div>
</div>
</div>

<p>Тем не менее, бывают ситуации, когда вам нужно запустить динамически сконструированную последовательность функций. Вы можете сделать это следующим образом:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> funcs = [foo, bar, baz, qux];
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span><span style="color:#080;font-weight:bold">var</span> result = Q(initialVal);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>funcs.forEach(<span style="color:#080;font-weight:bold">function</span> (f) {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    result = result.then(f);
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>});
<span class="line-numbers"><a href="#n7" name="n7">7</a></span><span style="color:#080;font-weight:bold">return</span> result;
</pre></div>
</div>
</div>

<p>Этот пример можно сделать немного короче, если использовать функцию <code>reduce</code> (учтите, что метод <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">method</a> для массивов представлен в спецификации ECMAScript 5):</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> funcs.reduce(<span style="color:#080;font-weight:bold">function</span> (soFar, f) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">return</span> soFar.then(f);
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>}, Q(initialVal));
</pre></div>
</div>
</div>

<p>Или же вы можете использовать этот супер-компактный вариант, использую статический метод <code>Q.when</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> funcs.reduce(Q.when, Q(initialVal));
</pre></div>
</div>
</div>

<h2 id="section-2">Обработка ошибок</h2>

<p>Некоторым кажется не очевидным один аспект работы промисов. Рассмотрим его подробнее: если вы выбросите исключение в обработчике успешного результата функции (первый аргумент <code>then</code>), то оно не будет поймано обработчиком ошибки (второй аргумент <code>then</code>)</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> foo()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (value) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Can't bar.</span><span style="color:#710">&quot;</span></span>);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}, <span style="color:#080;font-weight:bold">function</span> (error) {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    <span style="color:#777">// сюда мы придем только тогда, когда foo &quot;упадет&quot;</span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>});
</pre></div>
</div>
</div>

<p>Чтобы понять, почему так происходит, попробуейте думать о промисе как о блоке <code>try</code>/<code>catch</code>. Мы пытаемся выполнять функцию <code>foo()</code> как бы в блоке <code>try</code> и обработчик ошибки тут выступает в качестве блока <code>catch</code>. Обработчик успешного разрешения промиса в данном случае выступает как код, идущий <em>после</em> блока <code>try</code>/<code>catch</code>. Очевидно, что такой код нуждается в собственной обработке ошибок.  </p>

<p>В терминах промисов это значит, что вам нужно сделать цепочку вызовов с указанием обработчика ошибки:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> foo()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (value) {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Can't bar.</span><span style="color:#710">&quot;</span></span>);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>})
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>.fail(<span style="color:#080;font-weight:bold">function</span> (error) {
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    <span style="color:#777">// сюда мы придем как в случае ошибки в foo (так как ошибка &quot;всплывет&quot;), </span>
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    <span style="color:#777">// так и в случае ошибки резолв-хендлера </span>
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>});
</pre></div>
</div>
</div>

<h2 id="section-3">Оповещения о прогрессе выполнения</h2>

<p>В библиотеке реализована возможность промисам сообщать собственный прогресс выполнения, например, для долгих задач, таких как загрузка файла. Вы должны понимать, что не все промисы автоматически реализуют такую возможность. Но для тех промисов, что это делают, у вас есть возможсть получить прогресс используя третий параметр функции <code>then</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> uploadFile()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span style="color:#777">// Тут мы успешно загрузили файл</span>
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>}, <span style="color:#080;font-weight:bold">function</span> (err) {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>    <span style="color:#777">// Тут мы получаем причину ошибки загрузки файла</span>
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>}, <span style="color:#080;font-weight:bold">function</span> (progress) {
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    <span style="color:#777">// Тут мы получаем оповещение о прогрессе в то время, пока файл загружается</span>
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>});
</pre></div>
</div>
</div>

<p>Q представляет нам более короткую форму записи (похожее мы видели на примере функции <code>fail</code>):</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> uploadFile().progress(<span style="color:#080;font-weight:bold">function</span> (progress) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#777">// Тут мы получаем оповещение о прогрессе</span>
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
</pre></div>
</div>
</div>

<h2 id="section-4">Окончание цепочки промисов</h2>

<p>Когда вы доходите до конца цепочки промисов, вы должны решить, хотите ли вы получить новый промис в качестве результата, или же вы хотите закончить цепочку. Если вы никак не используете полученный последний промис, то вы рискуете потерять какое-нибудь исключение по причине того, что промисы перехватывают ошибки.</p>

<p>Вместо того, чтобы возвращать последний промис вы можете закончить цепочку, вызвав метод <code>done()</code>.</p>

<p>Сравните:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#777">// возвращаем промис</span>
<span class="line-numbers"><a href="#n2" name="n2">2</a></span><span style="color:#080;font-weight:bold">return</span> foo()
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>.then(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bar</span><span style="color:#710">&quot;</span></span>;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>});
</pre></div>
</div>
</div>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span>foo()
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">return</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">bar</span><span style="color:#710">&quot;</span></span>;
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>})
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>.done();
</pre></div>
</div>
</div>

<p>Использование последнего варианта позволяет убедиться, что никакое исключение не будет потеряно в ходе обработки промиса. Если вы не обработали его в цепочке вызовов, то оно будет выброшено. Эта мера позволяет вам увидеть проблемы в коде и среагировать на них.</p>

<h2 id="section-5">С чего начать?</h2>

<p>Все, что было написано выше было рассчитано на то, что вы уже взяли где-то готовый промис. Давайте теперь посмотрим, как мы можем создать промис самостоятельно.</p>

<h3 id="qfcall">Используем <code>Q.fcall</code></h3>

<p>Вы можете вернуть промис для какого-то значения, используя <code>Q.fcall</code>. В следующем примере мы получим промис для значения 10.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> Q.fcall(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">return</span> <span style="color:#00D">10</span>;
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
</pre></div>
</div>
</div>

<p>Также вы можете использовать <code>fcall</code> для получения промиса исключения:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> Q.fcall(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">throw</span> <span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Can't do it</span><span style="color:#710">&quot;</span></span>);
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>});
</pre></div>
</div>
</div>

<p>Как нам обещает название, <code>fcall</code> может быть использован для вызова функций и даже для вызова тех функций, которые возвращают промисы:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">return</span> Q.fcall(eventualAdd, <span style="color:#00D">2</span>, <span style="color:#00D">2</span>);
</pre></div>
</div>
</div>

<h3 id="deferreds">Использование Deferreds</h3>

<p>Если вы имеете дело с асинхронными функциями, которые используют коллбек, а не промисы, вы можете использовать существующие шоткаты, которые представляет Q (например <code>Q.nfcall</code>). Тем не менее, в большинстве случаев вам будет удобнее воспользоваться объектами <code>deferred</code>. </p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">var</span> deferred = Q.defer();
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>FS.readFile(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">foo.txt</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">utf-8</span><span style="color:#710">&quot;</span></span>, <span style="color:#080;font-weight:bold">function</span> (error, text) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">if</span> (error) {
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>        deferred.reject(<span style="color:#080;font-weight:bold">new</span> Error(error));
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    } <span style="color:#080;font-weight:bold">else</span> {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>        deferred.resolve(text);
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    }
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>});
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span><span style="color:#080;font-weight:bold">return</span> deferred.promise;
</pre></div>
</div>
</div>

<p>Обработе внимание, что <code>deferred</code> может быть разрешен при помощи значения или другого промиса.</p>

<p>Давайте на примере посмотрим, как мы можем использовать промисы на практике. Ниже приведена упрощенная реализация <code>Q.delay</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">delay</span>(ms) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">var</span> deferred = Q.defer();
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    setTimeout(deferred.resolve, ms);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    <span style="color:#080;font-weight:bold">return</span> deferred.promise;
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>}
</pre></div>
</div>
</div>

<p>В следующем примере рассмотрим реализацию <code>Q.timeout</code>.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"><a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">timeout</span>(promise, ms) {
<span class="line-numbers"><a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">var</span> deferred = Q.defer();
<span class="line-numbers"><a href="#n3" name="n3">3</a></span>    Q.when(promise, deferred.resolve);
<span class="line-numbers"><a href="#n4" name="n4">4</a></span>    delay(ms).then(<span style="color:#080;font-weight:bold">function</span> () {
<span class="line-numbers"><a href="#n5" name="n5">5</a></span>        deferred.reject(<span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Timed out</span><span style="color:#710">&quot;</span></span>));
<span class="line-numbers"><a href="#n6" name="n6">6</a></span>    });
<span class="line-numbers"><a href="#n7" name="n7">7</a></span>    <span style="color:#080;font-weight:bold">return</span> deferred.promise;
<span class="line-numbers"><a href="#n8" name="n8">8</a></span>}
</pre></div>
</div>
</div>

<p>Не обойдем вниманием и отправку оповещений о прогрессе выполнения с использованием метода <code>deferred.notify</code>.</p>

<p>Для иллюстрации, давайте напишем простую обертку над браузерным XMLHttpRequest.</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span><span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">requestOkText</span>(url) {
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>    <span style="color:#080;font-weight:bold">var</span> request = <span style="color:#080;font-weight:bold">new</span> XMLHttpRequest();
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>    <span style="color:#080;font-weight:bold">var</span> deferred = Q.defer();
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>    request.open(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">GET</span><span style="color:#710">&quot;</span></span>, url, <span style="color:#069">true</span>);
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    request.onload = onload;
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    request.onerror = onerror;
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>    request.onprogress = onprogress;
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    request.send();
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>    <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onload</span>() {
<span class="line-numbers"><a href="#n12" name="n12">12</a></span>        <span style="color:#080;font-weight:bold">if</span> (request.status === <span style="color:#00D">200</span>) {
<span class="line-numbers"><a href="#n13" name="n13">13</a></span>            deferred.resolve(request.responseText);
<span class="line-numbers"><a href="#n14" name="n14">14</a></span>        } <span style="color:#080;font-weight:bold">else</span> {
<span class="line-numbers"><a href="#n15" name="n15">15</a></span>            deferred.reject(<span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Status code was </span><span style="color:#710">&quot;</span></span> + request.status));
<span class="line-numbers"><a href="#n16" name="n16">16</a></span>        }
<span class="line-numbers"><a href="#n17" name="n17">17</a></span>    }
<span class="line-numbers"><a href="#n18" name="n18">18</a></span>
<span class="line-numbers"><a href="#n19" name="n19">19</a></span>    <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onerror</span>() {
<span class="line-numbers"><strong><a href="#n20" name="n20">20</a></strong></span>        deferred.reject(<span style="color:#080;font-weight:bold">new</span> Error(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Can't XHR </span><span style="color:#710">&quot;</span></span> + JSON.stringify(url)));
<span class="line-numbers"><a href="#n21" name="n21">21</a></span>    }
<span class="line-numbers"><a href="#n22" name="n22">22</a></span>
<span class="line-numbers"><a href="#n23" name="n23">23</a></span>    <span style="color:#080;font-weight:bold">function</span> <span style="color:#06B;font-weight:bold">onprogress</span>(event) {
<span class="line-numbers"><a href="#n24" name="n24">24</a></span>        deferred.notify(event.loaded / event.total);
<span class="line-numbers"><a href="#n25" name="n25">25</a></span>    }
<span class="line-numbers"><a href="#n26" name="n26">26</a></span>
<span class="line-numbers"><a href="#n27" name="n27">27</a></span>    <span style="color:#080;font-weight:bold">return</span> deferred.promise;
<span class="line-numbers"><a href="#n28" name="n28">28</a></span>}
</pre></div>
</div>
</div>

<p>Давайте посмотрим, как мы можем использовать получившуюся <code>requestOkText</code>:</p>

<div><div class="CodeRay">
  <div class="code"><pre><span class="line-numbers"> <a href="#n1" name="n1">1</a></span>requestOkText(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">http://localhost:3000</span><span style="color:#710">&quot;</span></span>)
<span class="line-numbers"> <a href="#n2" name="n2">2</a></span>.then(<span style="color:#080;font-weight:bold">function</span> (responseText) {
<span class="line-numbers"> <a href="#n3" name="n3">3</a></span>                <span style="color:#777">// Если HTTP запрос вернет код 200 OK, то мы логируем текст ответа</span>
<span class="line-numbers"> <a href="#n4" name="n4">4</a></span>    console.log(responseText);
<span class="line-numbers"> <a href="#n5" name="n5">5</a></span>}, <span style="color:#080;font-weight:bold">function</span> (error) {
<span class="line-numbers"> <a href="#n6" name="n6">6</a></span>    <span style="color:#777">// Если в ходе запроса произошла ошибка или вернулся не 200 OK, то мы логируем ошибку</span>
<span class="line-numbers"> <a href="#n7" name="n7">7</a></span>    console.error(error);
<span class="line-numbers"> <a href="#n8" name="n8">8</a></span>}, <span style="color:#080;font-weight:bold">function</span> (progress) {
<span class="line-numbers"> <a href="#n9" name="n9">9</a></span>    <span style="color:#777">// Логируем прогресс выполнения запроса:</span>
<span class="line-numbers"><strong><a href="#n10" name="n10">10</a></strong></span>    console.log(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Request progress: </span><span style="color:#710">&quot;</span></span> + Math.round(progress * <span style="color:#00D">100</span>) + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">%</span><span style="color:#710">&quot;</span></span>);
<span class="line-numbers"><a href="#n11" name="n11">11</a></span>});
</pre></div>
</div>
</div>

<h2 id="section-6">Источники</h2>

<ul>
  <li><a href="https://github.com/kriskowal/q/blob/master/README.md">Официальная документация</a></li>
</ul>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Stanislav Panferov</h2>

    <div class="footer-col-wrapper">

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/s-panferov">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">s-panferov</span>
            </a>
          </li>
          

          <li>
            <a href="http://ru.linkedin.com/pub/stanislav-panferov/65/bb2/a30">
              <span class="icon">
                <svg width="16px" height="16px" viewBox="0 0 60 60" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                    <path d="M0.449161376,30 C0.449161376,13.4314567 13.6795217,0 30,0 C46.3204783,0 59.5508386,13.4314567 59.5508386,30 C59.5508386,46.5685433 46.3204783,60 30,60 C13.6795217,60 0.449161376,46.5685433 0.449161376,30 Z M0.449161376,30" fill="#007BB6" sketch:type="MSShapeGroup"></path>
                    <path d="M22.4680392,23.7098144 L15.7808366,23.7098144 L15.7808366,44.1369537 L22.4680392,44.1369537 L22.4680392,23.7098144 Z M22.4680392,23.7098144" id="Path" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>
                    <path d="M22.9084753,17.3908761 C22.8650727,15.3880081 21.4562917,13.862504 19.1686418,13.862504 C16.8809918,13.862504 15.3854057,15.3880081 15.3854057,17.3908761 C15.3854057,19.3522579 16.836788,20.9216886 19.0818366,20.9216886 L19.1245714,20.9216886 C21.4562917,20.9216886 22.9084753,19.3522579 22.9084753,17.3908761 Z M22.9084753,17.3908761" id="Path" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>
                    <path d="M46.5846502,32.4246563 C46.5846502,26.1503226 43.2856534,23.2301456 38.8851658,23.2301456 C35.3347011,23.2301456 33.7450983,25.2128128 32.8575489,26.6036896 L32.8575489,23.7103567 L26.1695449,23.7103567 C26.2576856,25.6271338 26.1695449,44.137496 26.1695449,44.137496 L32.8575489,44.137496 L32.8575489,32.7292961 C32.8575489,32.1187963 32.9009514,31.5097877 33.0777669,31.0726898 C33.5610713,29.8530458 34.6614937,28.5902885 36.5089747,28.5902885 C38.9297703,28.5902885 39.8974476,30.4634101 39.8974476,33.2084226 L39.8974476,44.1369537 L46.5843832,44.1369537 L46.5846502,32.4246563 Z M46.5846502,32.4246563" id="Path" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>
                    <path d="M59.5508386,30 C59.5508386,46.5685433 46.3204783,60 30,60 C23.9471212,60 18.3192858,58.1525134 13.6339051,54.9827754 L47.4941264,5.81941103 C54.8060245,11.2806503 59.5508386,20.0777973 59.5508386,30 Z M59.5508386,30" id="reflec" fill-opacity="0.08" fill="#000000" sketch:type="MSShapeGroup"></path>
                </svg>
              </span>

              <span class="username">linkedin profile</span>
            </a>
          </li>

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Personal web blog about software development and code design.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
